<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC CCTV Viewer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        .header {
            text-align: center;
            margin-bottom: 20px;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .control-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        input, button {
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        button.secondary {
            background-color: #2196F3;
        }
        button.danger {
            background-color: #f44336;
        }
        #status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            background-color: #f0f0f0;
        }
        .cameras-container {
            margin: 20px 0;
        }
        .camera-item {
            padding: 10px;
            border: 1px solid #ddd;
            margin: 5px 0;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .camera-item button {
            padding: 5px 10px;
            font-size: 14px;
        }
        .video-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .video-item {
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 10px;
        }
        .video-item h3 {
            margin-top: 0;
        }
        video {
            width: 100%;
            height: 300px;
            background-color: #000;
        }
        .log {
            height: 200px;
            overflow-y: scroll;
            border: 1px solid #ccc;
            padding: 10px;
            background-color: #f9f9f9;
            font-family: monospace;
            font-size: 12px;
            margin-top: 20px;
        }
        .info-panel {
            background-color: #e3f2fd;
            padding: 15px;
            border-radius: 4px;
            margin: 20px 0;
        }
        .nav-links {
            text-align: center;
            margin: 20px 0;
        }
        .nav-links a {
            margin: 0 10px;
            padding: 10px 15px;
            background-color: #2196F3;
            color: white;
            text-decoration: none;
            border-radius: 4px;
        }
        .nav-links a:hover {
            background-color: #1976D2;
        }
        .room-controls {
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
        }
        .room-info {
            margin-top: 10px;
            padding: 10px;
            background-color: #e8f5e9;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>WebRTC CCTV Viewer</h1>
        <p>Connect to view live footage from ESP32 cameras</p>
    </div>
    
    <div class="nav-links">
        <a href="/">Viewer Page</a>
        <a href="/esp32-camera.html">ESP32 Camera Simulator</a>
    </div>
    
    <div class="info-panel">
        <h3>How to Use This System</h3>
        <p>1. <a href="/esp32-camera.html">Open the ESP32 Camera Simulator</a> to simulate a camera device</p>
        <p>2. Connect as a camera with a unique ID</p>
        <p>3. Return to this page and connect as a viewer</p>
        <p>4. Request to view the camera by its ID</p>
        <p>5. View live footage from the simulated camera</p>
    </div>
    
    <div class="room-controls">
        <h3>Room Management</h3>
        <div class="control-group">
            <input type="text" id="roomNameInput" placeholder="Enter room name" value="cctv">
            <button id="createRoomBtn">Create/Join Room</button>
            <button id="leaveRoomBtn" disabled>Leave Room</button>
        </div>
        <div class="room-info">
            <p>Current Room: <span id="currentRoom">Not in a room</span></p>
            <p>Room Status: <span id="roomStatus">Disconnected</span></p>
        </div>
    </div>
    
    <div id="status">Not connected</div>
    
    <div class="controls">
        <div class="control-group">
            <button id="connectBtn">Connect to Server</button>
            <button id="disconnectBtn" disabled>Disconnect</button>
        </div>
        
        <div class="control-group">
            <input type="text" id="cameraIdInput" placeholder="Enter Camera ID to view">
            <button id="viewBtn" disabled>View Camera</button>
        </div>
        
        <div class="control-group">
            <button id="refreshBtn" disabled>Refresh Camera List</button>
        </div>
    </div>
    
    <div class="cameras-container">
        <h2>Available Cameras</h2>
        <div id="camerasList">
            <p>No cameras available. Connect cameras to the network.</p>
        </div>
    </div>
    
    <div class="video-container" id="videoContainer">
        <!-- Video streams will be added here dynamically -->
    </div>
    
    <h3>Connection Log</h3>
    <div id="log" class="log"></div>

    <script>
        // DOM elements
        const connectBtn = document.getElementById('connectBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const viewBtn = document.getElementById('viewBtn');
        const refreshBtn = document.getElementById('refreshBtn');
        const cameraIdInput = document.getElementById('cameraIdInput');
        const statusDiv = document.getElementById('status');
        const logDiv = document.getElementById('log');
        const camerasList = document.getElementById('camerasList');
        const videoContainer = document.getElementById('videoContainer');
        const roomNameInput = document.getElementById('roomNameInput');
        const createRoomBtn = document.getElementById('createRoomBtn');
        const leaveRoomBtn = document.getElementById('leaveRoomBtn');
        const currentRoomSpan = document.getElementById('currentRoom');
        const roomStatusSpan = document.getElementById('roomStatus');
        
        // Variables
        let ws;
        let clientId;
        let currentRoom = null;
        let availableCameras = new Map();
        let activeStreams = new Map();
        let peerConnections = new Map();
        
        // Configuration
        const config = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        };
        
        // Log function
        function log(message) {
            const time = new Date().toLocaleTimeString();
            logDiv.innerHTML += `[${time}] ${message}\n`;
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(message);
        }
        
        // Connect to signaling server
        connectBtn.onclick = () => {
            const protocol = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
            const wsUrl = protocol + window.location.host;
            
            log(`Connecting to signaling server at ${wsUrl}`);
            ws = new WebSocket(wsUrl);
            
            ws.onopen = () => {
                log('Connected to signaling server');
                statusDiv.textContent = 'Connected to signaling server';
                statusDiv.style.backgroundColor = '#d4edda';
                connectBtn.disabled = true;
                disconnectBtn.disabled = false;
                createRoomBtn.disabled = false;
            };
            
            ws.onmessage = (event) => {
                const message = JSON.parse(event.data);
                log(`Received: ${message.type}`);
                
                switch (message.type) {
                    case 'welcome':
                        clientId = message.clientId;
                        log(`Assigned client ID: ${clientId}`);
                        break;
                        
                    case 'joined':
                        currentRoom = message.room;
                        currentRoomSpan.textContent = currentRoom;
                        roomStatusSpan.textContent = 'Joined';
                        roomStatusSpan.style.color = 'green';
                        log(`Joined room: ${message.room}`);
                        viewBtn.disabled = false;
                        refreshBtn.disabled = false;
                        leaveRoomBtn.disabled = false;
                        break;
                        
                    case 'offer':
                        handleOffer(message);
                        break;
                        
                    case 'answer':
                        handleAnswer(message);
                        break;
                        
                    case 'iceCandidate':
                        handleIceCandidate(message);
                        break;
                        
                    case 'clientJoined':
                        log(`Client ${message.clientId} joined the room (${message.deviceType})`);
                        break;
                        
                    case 'cameraAvailable':
                        log(`Camera ${message.cameraId} is now available`);
                        availableCameras.set(message.cameraId, message.clientId);
                        updateCamerasList();
                        break;
                        
                    case 'cameraUnavailable':
                        log(`Camera ${message.cameraId} is no longer available`);
                        availableCameras.delete(message.cameraId);
                        updateCamerasList();
                        break;
                        
                    case 'cameraNotFound':
                        log(`Camera ${message.cameraId} not found`);
                        alert(`Camera ${message.cameraId} is not currently available`);
                        break;
                        
                    default:
                        log(`Unknown message type: ${message.type}`);
                }
            };
            
            ws.onclose = () => {
                log('Disconnected from signaling server');
                statusDiv.textContent = 'Disconnected from signaling server';
                statusDiv.style.backgroundColor = '#f8d7da';
                connectBtn.disabled = false;
                disconnectBtn.disabled = true;
                viewBtn.disabled = true;
                refreshBtn.disabled = true;
                createRoomBtn.disabled = true;
                leaveRoomBtn.disabled = true;
                currentRoom = null;
                currentRoomSpan.textContent = 'Not in a room';
                roomStatusSpan.textContent = 'Disconnected';
                roomStatusSpan.style.color = 'red';
                
                // Clear all active streams
                activeStreams.forEach((stream, cameraId) => {
                    stream.getTracks().forEach(track => track.stop());
                });
                activeStreams.clear();
                
                // Close all peer connections
                peerConnections.forEach(pc => pc.close());
                peerConnections.clear();
                
                // Clear UI
                videoContainer.innerHTML = '';
            };
            
            ws.onerror = (error) => {
                log(`WebSocket error: ${error}`);
            };
        };
        
        // Disconnect from server
        disconnectBtn.onclick = () => {
            if (ws) {
                ws.close();
            }
        };
        
        // Create or join room
        createRoomBtn.onclick = () => {
            const roomName = roomNameInput.value.trim();
            if (!roomName) {
                alert('Please enter a room name');
                return;
            }
            
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                log('Not connected to server');
                return;
            }
            
            // Leave current room if in one
            if (currentRoom) {
                log(`Leaving room ${currentRoom}`);
            }
            
            // Clear current camera list
            availableCameras.clear();
            updateCamerasList();
            
            // Join new room
            log(`Joining room: ${roomName}`);
            ws.send(JSON.stringify({
                type: 'join',
                room: roomName
                // Viewers don't need to specify deviceType, it defaults to 'viewer'
            }));
        };
        
        // Leave current room
        leaveRoomBtn.onclick = () => {
            if (!currentRoom) {
                log('Not in a room');
                return;
            }
            
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                log('Not connected to server');
                return;
            }
            
            // Clear current camera list
            availableCameras.clear();
            updateCamerasList();
            
            // Leave room by joining default room
            log(`Leaving room ${currentRoom}`);
            ws.send(JSON.stringify({
                type: 'join',
                room: 'default'
            }));
            
            currentRoom = null;
            currentRoomSpan.textContent = 'Not in a room';
            roomStatusSpan.textContent = 'Disconnected';
            roomStatusSpan.style.color = 'red';
            viewBtn.disabled = true;
            refreshBtn.disabled = true;
            leaveRoomBtn.disabled = true;
        };
        
        // View a specific camera
        viewBtn.onclick = () => {
            const cameraId = cameraIdInput.value.trim();
            if (!cameraId) {
                alert('Please enter a camera ID');
                return;
            }
            
            if (!currentRoom) {
                alert('Please join a room first');
                return;
            }
            
            if (availableCameras.has(cameraId)) {
                requestCameraStream(cameraId);
            } else {
                // Request stream anyway - server will check if camera exists
                requestCameraStream(cameraId);
            }
        };
        
        // Refresh camera list
        refreshBtn.onclick = () => {
            if (!currentRoom) {
                log('Not in a room');
                return;
            }
            
            // Request updated camera list from server
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'join',
                    room: currentRoom
                }));
                log('Refreshing camera list...');
            }
        };
        
        // Request camera stream
        function requestCameraStream(cameraId) {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                log('Not connected to server');
                return;
            }
            
            if (!currentRoom) {
                log('Not in a room');
                return;
            }
            
            log(`Requesting stream from camera ${cameraId} in room ${currentRoom}`);
            ws.send(JSON.stringify({
                type: 'requestStream',
                cameraId: cameraId,
                requestId: Date.now().toString()
            }));
            
            // Pre-create peer connection for this camera using cameraId as key
            if (!peerConnections.has(cameraId)) {
                createPeerConnection(cameraId);
            }
        }
        
        // Update cameras list UI
        function updateCamerasList() {
            if (availableCameras.size === 0) {
                camerasList.innerHTML = '<p>No cameras available. Connect cameras to the network.</p>';
                return;
            }
            
            let html = '<div>';
            availableCameras.forEach((clientId, cameraId) => {
                html += `
                    <div class="camera-item">
                        <span>Camera ID: ${cameraId}</span>
                        <button onclick="requestCameraStream('${cameraId}')">View</button>
                    </div>
                `;
            });
            html += '</div>';
            camerasList.innerHTML = html;
        }
        
        // Create peer connection
        function createPeerConnection(cameraId) {
            const peerConnection = new RTCPeerConnection(config);
            
            // Handle ICE candidates
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    log(`Sending ICE candidate to camera ${cameraId}`);
                    // Find the client ID for this camera
                    let targetClientId = null;
                    availableCameras.forEach((clientId, id) => {
                        if (id === cameraId) {
                            targetClientId = clientId;
                        }
                    });
                    
                    if (targetClientId && ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({
                            type: 'iceCandidate',
                            target: targetClientId,
                            candidate: event.candidate
                        }));
                    }
                }
            };
            
            // Handle remote stream
            peerConnection.ontrack = (event) => {
                log(`Received video stream from camera ${cameraId}`);
                const stream = event.streams[0];
                activeStreams.set(cameraId, stream);
                displayVideoStream(cameraId, stream);
            };
            
            // Handle connection state changes
            peerConnection.onconnectionstatechange = () => {
                log(`Connection state with camera ${cameraId}: ${peerConnection.connectionState}`);
                if (peerConnection.connectionState === 'disconnected' || 
                    peerConnection.connectionState === 'failed') {
                    peerConnections.delete(cameraId);
                    if (activeStreams.has(cameraId)) {
                        activeStreams.delete(cameraId);
                    }
                }
            };
            
            peerConnection.onsignalingstatechange = () => {
                log(`Signaling state with camera ${cameraId}: ${peerConnection.signalingState}`);
            };
            
            peerConnection.oniceconnectionstatechange = () => {
                log(`ICE connection state with camera ${cameraId}: ${peerConnection.iceConnectionState}`);
            };
            
            // Store the peer connection
            peerConnections.set(cameraId, peerConnection);
            return peerConnection;
        }
        
        // Display video stream in UI
        function displayVideoStream(cameraId, stream) {
            // Check if video element already exists
            let videoContainerEl = document.getElementById(`video-${cameraId}`);
            if (!videoContainerEl) {
                videoContainerEl = document.createElement('div');
                videoContainerEl.id = `video-${cameraId}`;
                videoContainerEl.className = 'video-item';
                videoContainerEl.innerHTML = `
                    <h3>Camera ${cameraId}</h3>
                    <video id="video-${cameraId}-player" autoplay></video>
                    <button class="danger" onclick="stopCameraStream('${cameraId}')" style="margin-top: 10px;">Stop Viewing</button>
                `;
                videoContainer.appendChild(videoContainerEl);
            }
            
            const videoElement = document.getElementById(`video-${cameraId}-player`);
            videoElement.srcObject = stream;
        }
        
        // Stop viewing a camera
        function stopCameraStream(cameraId) {
            // Close peer connection
            if (peerConnections.has(cameraId)) {
                peerConnections.get(cameraId).close();
                peerConnections.delete(cameraId);
            }
            
            // Stop stream tracks
            if (activeStreams.has(cameraId)) {
                activeStreams.get(cameraId).getTracks().forEach(track => track.stop());
                activeStreams.delete(cameraId);
            }
            
            // Remove video element
            const videoContainerEl = document.getElementById(`video-${cameraId}`);
            if (videoContainerEl) {
                videoContainerEl.remove();
            }
            
            log(`Stopped viewing camera ${cameraId}`);
        }
        
        // Handle offer from camera
        async function handleOffer(message) {
            try {
                log(`Received offer from camera ${message.sender}`);
                
                // Find the cameraId for this sender
                let cameraId = null;
                availableCameras.forEach((clientId, id) => {
                    if (clientId === message.sender) {
                        cameraId = id;
                    }
                });
                
                if (!cameraId) {
                    log(`Could not find camera ID for sender ${message.sender}`);
                    return;
                }
                
                // Get or create peer connection for this camera
                let peerConnection;
                if (!peerConnections.has(cameraId)) {
                    peerConnection = createPeerConnection(cameraId);
                } else {
                    peerConnection = peerConnections.get(cameraId);
                }
                
                await peerConnection.setRemoteDescription(new RTCSessionDescription(message.sdp));
                
                log(`Creating answer for camera ${cameraId}`);
                const answer = await peerConnection.createAnswer({
                    offerToReceiveVideo: true,
                    offerToReceiveAudio: false
                });
                
                await peerConnection.setLocalDescription(answer);
                
                log(`Sending answer to camera ${message.sender}`);
                ws.send(JSON.stringify({
                    type: 'answer',
                    target: message.sender,
                    sdp: answer
                }));
            } catch (error) {
                log(`Error handling offer from camera ${message.sender}: ${error}`);
            }
        }
        
        // Handle answer from camera
        async function handleAnswer(message) {
            try {
                log(`Received answer from camera ${message.sender}`);
                // Find the cameraId for this sender
                let cameraId = null;
                availableCameras.forEach((clientId, id) => {
                    if (clientId === message.sender) {
                        cameraId = id;
                    }
                });
                
                if (!cameraId) {
                    log(`Could not find camera ID for sender ${message.sender}`);
                    return;
                }
                
                const peerConnection = peerConnections.get(cameraId);
                if (!peerConnection) {
                    log(`No peer connection found for camera ${cameraId}`);
                    return;
                }
                
                await peerConnection.setRemoteDescription(new RTCSessionDescription(message.sdp));
            } catch (error) {
                log(`Error handling answer from camera ${message.sender}: ${error}`);
            }
        }
        
        // Handle ICE candidate from camera
        async function handleIceCandidate(message) {
            try {
                log(`Received ICE candidate from camera ${message.sender}`);
                
                // Find the cameraId for this sender
                let cameraId = null;
                availableCameras.forEach((clientId, id) => {
                    if (clientId === message.sender) {
                        cameraId = id;
                    }
                });
                
                if (!cameraId) {
                    log(`Could not find camera ID for sender ${message.sender}`);
                    return;
                }
                
                const peerConnection = peerConnections.get(cameraId);
                if (!peerConnection) {
                    log(`No peer connection found for camera ${cameraId}`);
                    return;
                }
                
                await peerConnection.addIceCandidate(new RTCIceCandidate(message.candidate));
            } catch (error) {
                log(`Error handling ICE candidate from camera ${message.sender}: ${error}`);
            }
        }
        
        // Make functions available globally for inline event handlers
        window.requestCameraStream = requestCameraStream;
        window.stopCameraStream = stopCameraStream;
    </script>
</body>
</html>